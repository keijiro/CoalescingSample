#pragma kernel Scan
#pragma kernel Aggregate

float Luma(float3 rgb)
{
    const float3 prim = float3(0.2126729, 0.7151522, 0.0721750);
    return saturate(dot(prim, rgb));
}

uint2 Dims;

Texture2D<float4> Source;
RWStructuredBuffer<uint> TempOut;

#define THREAD_COUNT 32
#define BIN_COUNT 256

groupshared uint s_bins[THREAD_COUNT][BIN_COUNT];

[numthreads(THREAD_COUNT, 1, 1)]
void Scan(uint group : SV_GroupID,
          uint thread : SV_GroupThreadID,
          uint x : SV_DispatchThreadID)
{
    for (uint i = 0; i < BIN_COUNT; i++)
    {
        s_bins[thread][i] = 0;
    }

    for (uint y = 0; y < Dims.y; y++)
    {
        uint br = Luma(Source[uint2(x, y)].rgb) * (BIN_COUNT - 1);
        s_bins[thread][br]++;
    }

    GroupMemoryBarrierWithGroupSync();

    for (i = x; i < BIN_COUNT; i += THREAD_COUNT)
    {
        uint sum = 0;
        for (uint j = 0; j < THREAD_COUNT; j++)
            sum += s_bins[j][i];
        TempOut[group * BIN_COUNT + i] = sum;
    }
}

StructuredBuffer<uint> TempIn;
RWStructuredBuffer<uint> TotalOut;

[numthreads(32, 1, 1)]
void Aggregate(uint id : SV_DispatchThreadID)
{
    uint acc = 0;

    for (uint i = 0; i < Dims.x / THREAD_COUNT; i++)
        acc += TempIn[i * BIN_COUNT + id];

    TotalOut[id] = acc;
}
